"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isStdlib = exports.hasMessage = exports.hasWarningMessage = exports.hasErrorMessage = exports.StringBuilder = exports.updateSource = exports.isMethodNamed = exports.className = exports.isEntry = exports.isUserEntry = exports.cloneNode = exports.getTypeName = exports.getName = exports.toString = exports.not = exports.isLibrary = exports.getDecorator = exports.hasDecorator = exports.isDecorator = exports.decorates = void 0;
const as_1 = require("../as");
const astBuilder_1 = require("./astBuilder");
const cloneDeep = require("lodash.clonedeep");
function decorates(node, name) {
    return node.name.text === name;
}
exports.decorates = decorates;
function isDecorator(name) {
    return (node) => decorates(node, name);
}
exports.isDecorator = isDecorator;
function hasDecorator(node, name) {
    var _a;
    let decl;
    if (node instanceof as_1.DeclarationStatement) {
        decl = node;
    }
    else {
        decl = node.declaration;
    }
    // because it could be undefined
    return ((_a = decl.decorators) === null || _a === void 0 ? void 0 : _a.some(isDecorator(name))) == true;
}
exports.hasDecorator = hasDecorator;
function getDecorator(node, name) {
    var _a;
    return (_a = node.decorators) === null || _a === void 0 ? void 0 : _a.find(isDecorator(name));
}
exports.getDecorator = getDecorator;
function isLibrary(node) {
    return node.isLibrary || node.internalPath.startsWith("~lib/rt/");
}
exports.isLibrary = isLibrary;
function not(fn) {
    return (t) => !fn(t);
}
exports.not = not;
function toString(node) {
    return astBuilder_1.ASTBuilder.build(node);
}
exports.toString = toString;
function getName(node) {
    if (node instanceof as_1.TypeNode) {
        if (node instanceof as_1.NamedTypeNode) {
            let name = getTypeName(node.name);
            const typeParameters = node.typeArguments;
            if (typeParameters && typeParameters.length > 0) {
                name += `<${typeParameters.map(getName).join(", ")}>`;
            }
            return name;
        }
        else if (node instanceof as_1.TypeName) {
            return toString(node.identifier);
        }
        return "";
    }
    if (node instanceof as_1.ClassDeclaration || node instanceof as_1.InterfaceDeclaration || node instanceof as_1.FunctionDeclaration) {
        return className(node);
    }
    return toString(node.name);
}
exports.getName = getName;
function getTypeName(node) {
    let name = toString(node.identifier);
    if (node.next) {
        name += getTypeName(node.next);
    }
    return name;
}
exports.getTypeName = getTypeName;
function cloneNode(node) {
    return cloneDeep(node);
}
exports.cloneNode = cloneNode;
function isUserEntry(node) {
    return node.range.source.sourceKind == as_1.SourceKind.USER_ENTRY;
}
exports.isUserEntry = isUserEntry;
function isEntry(node) {
    return isUserEntry(node) || node.range.source.sourceKind == as_1.SourceKind.LIBRARY_ENTRY;
}
exports.isEntry = isEntry;
function className(_class) {
    let name = toString(_class.name);
    const typeParameters = _class.typeParameters;
    if (typeParameters) {
        name += `<${typeParameters.map(getName).join(", ")}>`;
    }
    return name;
}
exports.className = className;
function isMethodNamed(name) {
    return (stmt) => stmt.kind == as_1.NodeKind.METHODDECLARATION && toString(stmt.name) === name;
}
exports.isMethodNamed = isMethodNamed;
function updateSource(program, newSource) {
    const sources = program.sources;
    for (let i = 0, len = sources.length; i < len; i++) {
        if (sources[i].internalPath == newSource.internalPath) {
            sources[i] = newSource;
            break;
        }
    }
}
exports.updateSource = updateSource;
class StringBuilder {
    constructor() {
        this.sb = [];
    }
    push(s) {
        this.sb.push(s);
    }
    finish(separator = "\n") {
        let res = this.sb.join(separator);
        this.sb = [];
        return res;
    }
    get last() { return this.sb[this.sb.length - 1]; }
}
exports.StringBuilder = StringBuilder;
/**
 *
 * @param emitter DiagnosticEmitter
 * @returns return true if emitter have ERROR message
 */
function hasErrorMessage(emitter) {
    return hasMessage(emitter, as_1.DiagnosticCategory.ERROR);
}
exports.hasErrorMessage = hasErrorMessage;
/**
*
* @param emitter DiagnosticEmitter
* @returns return true if emitter have WARNING message
*/
function hasWarningMessage(emitter) {
    return hasMessage(emitter, as_1.DiagnosticCategory.WARNING);
}
exports.hasWarningMessage = hasWarningMessage;
/**
*
* @param emitter DiagnosticEmitter
* @returns return true if emitter have `category` message
*/
function hasMessage(emitter, category) {
    const diagnostics = emitter.diagnostics ? emitter.diagnostics : [];
    for (const msg of diagnostics) {
        if (msg.category === category) {
            return true;
        }
    }
    return false;
}
exports.hasMessage = hasMessage;
let isStdlibRegex = /\~lib\/(?:array|arraybuffer|atomics|builtins|crypto|console|compat|dataview|date|diagnostics|error|function|iterator|map|math|number|object|process|reference|regexp|set|staticarray|string|symbol|table|typedarray|vector|rt\/?|bindings\/|shared\/typeinfo)|util\/|uri|polyfills|memory/;
function isStdlib(s) {
    let source = s instanceof as_1.Source ? s : s.range.source;
    return isStdlibRegex.test(source.internalPath);
}
exports.isStdlib = isStdlib;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXRpbHMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi9zcmMvdXRpbHMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBQUEsOEJBa0JlO0FBQ2YsNkNBQTBDO0FBRTFDLE1BQU0sU0FBUyxHQUFtQixPQUFPLENBQUMsa0JBQWtCLENBQUMsQ0FBQztBQUU5RCxTQUFnQixTQUFTLENBQUMsSUFBbUIsRUFBRSxJQUFZO0lBQ3pELE9BQThCLElBQUksQ0FBQyxJQUFLLENBQUMsSUFBSSxLQUFLLElBQUksQ0FBQztBQUN6RCxDQUFDO0FBRkQsOEJBRUM7QUFFRCxTQUFnQixXQUFXLENBQUMsSUFBWTtJQUN0QyxPQUFPLENBQUMsSUFBSSxFQUFFLEVBQUUsQ0FBQyxTQUFTLENBQUMsSUFBSSxFQUFFLElBQUksQ0FBQyxDQUFDO0FBQ3pDLENBQUM7QUFGRCxrQ0FFQztBQUdELFNBQWdCLFlBQVksQ0FDMUIsSUFBZ0UsRUFDaEUsSUFBWTs7SUFFWixJQUFJLElBQUksQ0FBQztJQUNULElBQUksSUFBSSxZQUFZLHlCQUFvQixFQUFFO1FBQ3hDLElBQUksR0FBRyxJQUFJLENBQUM7S0FDYjtTQUFNO1FBQ0wsSUFBSSxHQUFHLElBQUksQ0FBQyxXQUFXLENBQUM7S0FDekI7SUFDRCxnQ0FBZ0M7SUFDaEMsT0FBTyxPQUFBLElBQUksQ0FBQyxVQUFVLDBDQUFFLElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLE1BQUssSUFBSSxDQUFDO0FBQzFELENBQUM7QUFaRCxvQ0FZQztBQUVELFNBQWdCLFlBQVksQ0FDMUIsSUFBMEIsRUFDMUIsSUFBWTs7SUFFWixPQUFPLE1BQUEsSUFBSSxDQUFDLFVBQVUsMENBQUUsSUFBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsQ0FBRSxDQUFDO0FBQ25ELENBQUM7QUFMRCxvQ0FLQztBQUVELFNBQWdCLFNBQVMsQ0FBQyxJQUFZO0lBQ3BDLE9BQU8sSUFBSSxDQUFDLFNBQVMsSUFBSSxJQUFJLENBQUMsWUFB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QyxPQUEwQjtJQUN6RCxPQUFPLFVBQVUsQ0FBQyxPQUFPLEVBQUUsdUJBQWtCLENBQUMsS0FBSyxDQUFDLENBQUM7QUFDdkQsQ0FBQztBQUZBLDBDQUVBO0FBRUQ7Ozs7RUFJRTtBQUNGLFNBQWdCLGlCQUFpQixDQUFDLE9BQTBCO0lBQzFELE9BQU8sVUFBVSxDQUFDLE9BQU8sRUFBRSx1QkFBa0IsQ0FBQyxPQUFPLENBQUMsQ0FBQztBQUN6RCxDQUFDO0FBRkQsOENBRUM7QUFFRDs7OztFQUlFO0FBQ0YsU0FBZ0IsVUFBVSxDQUN4QixPQUEwQixFQUMxQixRQUE0QjtJQUU1QixNQUFNLFdBQVcsR0FBRyxPQUFPLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUM7SUFDbkUsS0FBSyxNQUFNLEdBQUcsSUFBSSxXQUFXLEVBQUU7UUFDM0IsSUFBSSxHQUFHLENBQUMsUUFBUSxLQUFLLFFBQVEsRUFBRTtZQUMzQixPQUFPLElBQUksQ0FBQztTQUNmO0tBQ0o7SUFDRCxPQUFPLEtBQUssQ0FBQztBQUNmLENBQUM7QUFYRCxnQ0FXQztBQUdELElBQUksYUFBYSxHQUNmLDJSQUEyUixDQUFDO0FBRTlSLFNBQWdCLFFBQVEsQ0FBQyxDQUE0QjtJQUNuRCxJQUFJLE1BQU0sR0FBRyxDQUFDLFlBQVksV0FBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDO0lBQ3RELE9BQU8sYUFBYSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsWUFBWSxDQUFDLENBQUM7QUFDakQsQ0FBQztBQUhELDRCQUdDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgRGVjb3JhdG9yTm9kZSxcbiAgSWRlbnRpZmllckV4cHJlc3Npb24sXG4gIERlY2xhcmF0aW9uU3RhdGVtZW50LFxuICBTb3VyY2UsXG4gIE5vZGUsXG4gIFNvdXJjZUtpbmQsXG4gIFByb2dyYW0sXG4gIENsYXNzRGVjbGFyYXRpb24sXG4gIFR5cGVOb2RlLFxuICBOb2RlS2luZCxcbiAgSW50ZXJmYWNlRGVjbGFyYXRpb24sXG4gIEZ1bmN0aW9uRGVjbGFyYXRpb24sXG4gIFR5cGVOYW1lLFxuICBEaWFnbm9zdGljQ2F0ZWdvcnksXG4gIERpYWdub3N0aWNFbWl0dGVyLFxuICBOYW1lZFR5cGVOb2RlLFxuICBSYW5nZSxcbn0gZnJvbSBcIi4uL2FzXCI7XG5pbXBvcnQgeyBBU1RCdWlsZGVyIH0gZnJvbSBcIi4vYXN0QnVpbGRlclwiO1xuXG5jb25zdCBjbG9uZURlZXA6IDxUPih0OiBUKSA9PiBUID0gcmVxdWlyZShcImxvZGFzaC5jbG9uZWRlZXBcIik7XG5cbmV4cG9ydCBmdW5jdGlvbiBkZWNvcmF0ZXMobm9kZTogRGVjb3JhdG9yTm9kZSwgbmFtZTogc3RyaW5nKTogYm9vbGVhbiB7XG4gIHJldHVybiAoPElkZW50aWZpZXJFeHByZXNzaW9uPm5vZGUubmFtZSkudGV4dCA9PT0gbmFtZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzRGVjb3JhdG9yKG5hbWU6IHN0cmluZyk6IChub2RlOiBEZWNvcmF0b3JOb2RlKSA9PiBib29sZWFuIHtcbiAgcmV0dXJuIChub2RlKSA9PiBkZWNvcmF0ZXMobm9kZSwgbmFtZSk7XG59XG5cblxuZXhwb3J0IGZ1bmN0aW9uIGhhc0RlY29yYXRvcihcbiAgbm9kZTogRGVjbGFyYXRpb25TdGF0ZW1lbnQgfCB7ZGVjbGFyYXRpb246IERlY2xhcmF0aW9uU3RhdGVtZW50fSxcbiAgbmFtZTogc3RyaW5nXG4pOiBib29sZWFuIHtcbiAgbGV0IGRlY2w7XG4gIGlmIChub2RlIGluc3RhbmNlb2YgRGVjbGFyYXRpb25TdGF0ZW1lbnQpIHtcbiAgICBkZWNsID0gbm9kZTtcbiAgfSBlbHNlIHtcbiAgICBkZWNsID0gbm9kZS5kZWNsYXJhdGlvbjsgXG4gIH0gXG4gIC8vIGJlY2F1c2UgaXQgY291bGQgYmUgdW5kZWZpbmVkXG4gIHJldHVybiBkZWNsLmRlY29yYXRvcnM/LnNvbWUoaXNEZWNvcmF0b3IobmFtZSkpID09IHRydWU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXREZWNvcmF0b3IoXG4gIG5vZGU6IERlY2xhcmF0aW9uU3RhdGVtZW50LFxuICBuYW1lOiBzdHJpbmdcbik6IERlY29yYXRvck5vZGUge1xuICByZXR1cm4gbm9kZS5kZWNvcmF0b3JzPy5maW5kKGlzRGVjb3JhdG9yKG5hbWUpKSE7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0xpYnJhcnkobm9kZTogU291cmNlKTogYm9vbGVhbiB7XG4gIHJldHVybiBub2RlLmlzTGlicmFyeSB8fCBub2RlLmludGVybmFsUGF0aC5zdGFydHNXaXRoKFwifmxpYi9ydC9cIik7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBub3Q8VD4oZm46ICh0OiBUKSA9PiBib29sZWFuKTogKHQ6IFQpID0+IGJvb2xlYW4ge1xuICByZXR1cm4gKHQ6IFQpID0+ICFmbih0KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRvU3RyaW5nKG5vZGU6IE5vZGUpOiBzdHJpbmcge1xuICByZXR1cm4gQVNUQnVpbGRlci5idWlsZChub2RlKTtcbn1cblxuaW50ZXJmYWNlIE5hbWVkIHtcbiAgbmFtZTogSWRlbnRpZmllckV4cHJlc3Npb247XG59XG5cblxuZXhwb3J0IGZ1bmN0aW9uIGdldE5hbWUobm9kZTogTm9kZSAmIE5hbWVkIHwgVHlwZU5vZGUpOiBzdHJpbmcge1xuICBpZiAobm9kZSBpbnN0YW5jZW9mIFR5cGVOb2RlKSB7XG4gICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBOYW1lZFR5cGVOb2RlKSB7XG4gICAgICBsZXQgbmFtZSA9IGdldFR5cGVOYW1lKG5vZGUubmFtZSlcbiAgICAgIGNvbnN0IHR5cGVQYXJhbWV0ZXJzID0gbm9kZS50eXBlQXJndW1lbnRzO1xuICAgICAgaWYgKHR5cGVQYXJhbWV0ZXJzICYmIHR5cGVQYXJhbWV0ZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgbmFtZSArPSBgPCR7dHlwZVBhcmFtZXRlcnMubWFwKGdldE5hbWUpLmpvaW4oXCIsIFwiKX0+YDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuYW1lXG4gICAgfSBlbHNlIGlmIChub2RlIGluc3RhbmNlb2YgVHlwZU5hbWUpIHtcbiAgICAgIHJldHVybiB0b1N0cmluZyhub2RlLmlkZW50aWZpZXIpXG4gICAgfVxuICAgIHJldHVybiBcIlwiO1xuICB9XG4gIGlmIChub2RlIGluc3RhbmNlb2YgQ2xhc3NEZWNsYXJhdGlvbiB8fCBub2RlIGluc3RhbmNlb2YgSW50ZXJmYWNlRGVjbGFyYXRpb24gfHwgbm9kZSBpbnN0YW5jZW9mIEZ1bmN0aW9uRGVjbGFyYXRpb24pIHtcbiAgICByZXR1cm4gY2xhc3NOYW1lKG5vZGUpO1xuICB9IFxuICByZXR1cm4gdG9TdHJpbmcobm9kZS5uYW1lKTtcbn1cblxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0VHlwZU5hbWUobm9kZTogVHlwZU5hbWUpOiBzdHJpbmcge1xuICBsZXQgbmFtZSA9IHRvU3RyaW5nKG5vZGUuaWRlbnRpZmllcik7XG4gIGlmIChub2RlLm5leHQpIHtcbiAgICBuYW1lICs9IGdldFR5cGVOYW1lKG5vZGUubmV4dCk7XG4gIH1cbiAgcmV0dXJuIG5hbWU7XG4gIFxufVxuXG5leHBvcnQgZnVuY3Rpb24gY2xvbmVOb2RlPFQgZXh0ZW5kcyBOb2RlPihub2RlOiBUKTogVCB7XG4gIHJldHVybiBjbG9uZURlZXAobm9kZSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc1VzZXJFbnRyeShub2RlOiBOb2RlKTogYm9vbGVhbiB7XG4gIHJldHVybiBub2RlLnJhbmdlLnNvdXJjZS5zb3VyY2VLaW5kID09IFNvdXJjZUtpbmQuVVNFUl9FTlRSWTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzRW50cnkobm9kZTogTm9kZSk6IGJvb2xlYW4ge1xuICByZXR1cm4gaXNVc2VyRW50cnkobm9kZSkgfHwgbm9kZS5yYW5nZS5zb3VyY2Uuc291cmNlS2luZCA9PSBTb3VyY2VLaW5kLkxJQlJBUllfRU5UUlk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjbGFzc05hbWUoX2NsYXNzOiBDbGFzc0RlY2xhcmF0aW9uIHwgIEludGVyZmFjZURlY2xhcmF0aW9uIHwgRnVuY3Rpb25EZWNsYXJhdGlvbik6IHN0cmluZyB7XG4gIGxldCBuYW1lID0gdG9TdHJpbmcoX2NsYXNzLm5hbWUpXG4gIGNvbnN0IHR5cGVQYXJhbWV0ZXJzID0gX2NsYXNzLnR5cGVQYXJhbWV0ZXJzO1xuICBpZiAodHlwZVBhcmFtZXRlcnMpIHtcbiAgICBuYW1lICs9IGA8JHt0eXBlUGFyYW1ldGVycy5tYXAoZ2V0TmFtZSkuam9pbihcIiwgXCIpfT5gO1xuICB9XG4gIHJldHVybiBuYW1lO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNNZXRob2ROYW1lZChuYW1lOiBzdHJpbmcpOiAoXzogRGVjbGFyYXRpb25TdGF0ZW1lbnQpID0+IGJvb2xlYW4ge1xuICByZXR1cm4gKHN0bXQ6IERlY2xhcmF0aW9uU3RhdGVtZW50KSA9PiBzdG10LmtpbmQgPT0gTm9kZUtpbmQuTUVUSE9EREVDTEFSQVRJT04gJiYgdG9TdHJpbmcoc3RtdC5uYW1lKSA9PT0gbmFtZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVwZGF0ZVNvdXJjZShwcm9ncmFtOiBQcm9ncmFtLCBuZXdTb3VyY2U6IFNvdXJjZSkge1xuICBjb25zdCBzb3VyY2VzID0gcHJvZ3JhbS5zb3VyY2VzO1xuICBmb3IgKGxldCBpID0gMCwgbGVuID0gc291cmNlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgaWYgKHNvdXJjZXNbaV0uaW50ZXJuYWxQYXRoID09IG5ld1NvdXJjZS5pbnRlcm5hbFBhdGgpIHtcbiAgICAgICAgICBzb3VyY2VzW2ldID0gbmV3U291cmNlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBTdHJpbmdCdWlsZGVyIHtcbiAgcHJpdmF0ZSBzYjogc3RyaW5nW10gPSBbXTtcblxuICBwdXNoKHM6IHN0cmluZyk6IHZvaWQge1xuICAgIHRoaXMuc2IucHVzaChzKTtcbiAgfVxuXG4gIGZpbmlzaChzZXBhcmF0b3IgPSBcIlxcblwiKTogc3RyaW5nIHtcbiAgICBsZXQgcmVzID0gdGhpcy5zYi5qb2luKHNlcGFyYXRvcik7XG4gICAgdGhpcy5zYiA9IFtdO1xuICAgIHJldHVybiByZXM7XG4gIH1cblxuICBnZXQgIGxhc3QoKTogc3RyaW5nIHsgcmV0dXJuIHRoaXMuc2JbdGhpcy5zYi5sZW5ndGggLTFdfVxufVxuXG4vKipcbiAqXG4gKiBAcGFyYW0gZW1pdHRlciBEaWFnbm9zdGljRW1pdHRlclxuICogQHJldHVybnMgcmV0dXJuIHRydWUgaWYgZW1pdHRlciBoYXZlIEVSUk9SIG1lc3NhZ2VcbiAqL1xuIGV4cG9ydCBmdW5jdGlvbiBoYXNFcnJvck1lc3NhZ2UoZW1pdHRlcjogRGlhZ25vc3RpY0VtaXR0ZXIpOiBib29sZWFuIHtcbiAgcmV0dXJuIGhhc01lc3NhZ2UoZW1pdHRlciwgRGlhZ25vc3RpY0NhdGVnb3J5LkVSUk9SKTtcbn1cblxuLyoqXG4qXG4qIEBwYXJhbSBlbWl0dGVyIERpYWdub3N0aWNFbWl0dGVyXG4qIEByZXR1cm5zIHJldHVybiB0cnVlIGlmIGVtaXR0ZXIgaGF2ZSBXQVJOSU5HIG1lc3NhZ2VcbiovXG5leHBvcnQgZnVuY3Rpb24gaGFzV2FybmluZ01lc3NhZ2UoZW1pdHRlcjogRGlhZ25vc3RpY0VtaXR0ZXIpOiBib29sZWFuIHtcbiAgcmV0dXJuIGhhc01lc3NhZ2UoZW1pdHRlciwgRGlhZ25vc3RpY0NhdGVnb3J5LldBUk5JTkcpO1xufVxuXG4vKipcbipcbiogQHBhcmFtIGVtaXR0ZXIgRGlhZ25vc3RpY0VtaXR0ZXJcbiogQHJldHVybnMgcmV0dXJuIHRydWUgaWYgZW1pdHRlciBoYXZlIGBjYXRlZ29yeWAgbWVzc2FnZVxuKi9cbmV4cG9ydCBmdW5jdGlvbiBoYXNNZXNzYWdlKFxuICBlbWl0dGVyOiBEaWFnbm9zdGljRW1pdHRlcixcbiAgY2F0ZWdvcnk6IERpYWdub3N0aWNDYXRlZ29yeVxuKTogYm9vbGVhbiB7XG4gIGNvbnN0IGRpYWdub3N0aWNzID0gZW1pdHRlci5kaWFnbm9zdGljcyA/IGVtaXR0ZXIuZGlhZ25vc3RpY3MgOiBbXTtcbiAgZm9yIChjb25zdCBtc2cgb2YgZGlhZ25vc3RpY3MpIHtcbiAgICAgIGlmIChtc2cuY2F0ZWdvcnkgPT09IGNhdGVnb3J5KSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5cbmxldCBpc1N0ZGxpYlJlZ2V4ID1cbiAgL1xcfmxpYlxcLyg/OmFycmF5fGFycmF5YnVmZmVyfGF0b21pY3N8YnVpbHRpbnN8Y3J5cHRvfGNvbnNvbGV8Y29tcGF0fGRhdGF2aWV3fGRhdGV8ZGlhZ25vc3RpY3N8ZXJyb3J8ZnVuY3Rpb258aXRlcmF0b3J8bWFwfG1hdGh8bnVtYmVyfG9iamVjdHxwcm9jZXNzfHJlZmVyZW5jZXxyZWdleHB8c2V0fHN0YXRpY2FycmF5fHN0cmluZ3xzeW1ib2x8dGFibGV8dHlwZWRhcnJheXx2ZWN0b3J8cnRcXC8/fGJpbmRpbmdzXFwvfHNoYXJlZFxcL3R5cGVpbmZvKXx1dGlsXFwvfHVyaXxwb2x5ZmlsbHN8bWVtb3J5LztcblxuZXhwb3J0IGZ1bmN0aW9uIGlzU3RkbGliKHM6IFNvdXJjZSB8IHsgcmFuZ2U6IFJhbmdlIH0pOiBib29sZWFuIHtcbiAgbGV0IHNvdXJjZSA9IHMgaW5zdGFuY2VvZiBTb3VyY2UgPyBzIDogcy5yYW5nZS5zb3VyY2U7XG4gIHJldHVybiBpc1N0ZGxpYlJlZ2V4LnRlc3Qoc291cmNlLmludGVybmFsUGF0aCk7XG59Il19